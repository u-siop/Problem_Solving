#include <bits/stdc++.h>
using namespace std;

// 밟지 않을 계단의 합을 최솟값으로 구하는 방향
// bc 내가 밟을 계단의 합이 최대 == 밟지 않을 계단의 합 최소
// ~~1,2,3,4,5,6   밟지 않을 계단. 6은 반드시 밟아야함. 5가 반드시 밟지 말아야한다면(1+1 규칙에 의해), 4는 무조건 밟아야하나? ㅇㅇ 3도. 그리고 모름~~
// d[i] = i번째 계단까지 올라섰을 때, 밟지 않을 계단의 합의 최솟값, i는 반드시 밟지 않을 계단으로 간주
// n = 6, 10,20,15,25,10,20  -> d[1] == 10(1번째를 밟지 않을 계단으로 간주 + 최솟값)  d[2] == 20(2번째를 밟지 않을 계단으로 간주 + 최솟값)
//                              d[3] == 25(3번째를 밟지 않을 계단 + 최솟값(1,3))     d[4] == 45(4번째를 밟지 않을 계단으로 간주 + 최솟값 (2,4))
//                              d[5] == 35(5번째를 밟지 않을 계단 + 최솟값(1,3,5)) 

// d[1] == 10, d[2] == 20, d[3] == 15, d[4] == 35, d[25] == 25


int s[305];
int n;
int d[305][3];

int main(void){
  ios::sync_with_stdio(0);
  cin.tie(0);
  cin >> n;
  int tot = 0;
  for(int i = 1; i <= n; i++){
    cin >> s[i];
    tot += s[i];
  }
  if(n <= 2){
    cout << tot;
    return 0;
  }
  d[1] = s[1];
  d[2] = s[2];
  d[3] = s[3];
  for(int i = 4; i <= n-1; i++) d[i] = min(d[i-2],d[i-3])+s[i];
  cout << tot - min(d[n-1],d[n-2]);
}